                  2   $LIST
0000              4   
0000              5   ;DECLARATIONS
0000              6   CLK         EQU 14746000  ; Microcontroller system clock frequency in Hz
0000              7   CCU_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000              8   CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000              9   BAUD        EQU 115200
0000             10   BRVAL       EQU ((CLK/BAUD)-16)
0000             11   
0000             12   TIMER1_RATE   EQU 200     ; 200Hz, for a timer tick of 5ms
0000             13   TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             14   
0000             15   ; PINS INPUT OUTPUTS
0000             16   FLASH_CE EQU P2.4
0000             17   MY_MOSI EQU P2.2
0000             18   MY_MISO EQU P2.3
0000             19   MY_SCLK EQU P2.5
0000             20   
0000             21   ;Sound and power outputs
0000             22   SOUND equ P0.0
0000             23   POWER equ P2.7
0000             24   
0000             25   ;Boot Button
0000             26   BOOT_BUTTON equ P2.6
0000             27   ;Temp Min Sec buttons
0000             28   TEMP_BUTTON  equ P0.2            ; Inc temperature
0000             29   ALMIN_BUTTON  equ P0.3   ; Inc minutes
0000             30   ALSEC_BUTTON   equ P0.1          ; Inc seconds
0000             31   ;Start/Stop timer, Mode button
0000             32   STARTSTOP_BUTTON equ P3.0        ; Start/Stop process immediately, Settings
0000             33   MODE_BUTTON equ P3.1             ; Switch Displays between Clock, Current Temp, Settings/timer
0000             34   
0000             35   ; Commands supported by the SPI flash memory according to the datasheet
0000             36   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             37   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             38   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             39   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             40   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             41   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             42   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             43   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             44   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             45   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             46   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             47   
0000             48   CSEG
0000             49   
0000             50   ; Reset vector
0000             51   org 0x0000
0000 021081      52       ljmp MainProgram
0003             53       
0003             54   ; External interrupt 0 vector (not used in this code)
0003             55   org 0x0003
0003 32          56            reti
0004             57   
0004             58   ; Timer/Counter 0 overflow interrupt vector
000B             59   org 0x000B
000B 32          60            reti
000C             61   
000C             62   ; External interrupt 1 vector (not used in this code)
0013             63   org 0x0013
0013 32          64            reti
0014             65   
0014             66   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             67   org 0x001B
001B 02104A      68            ljmp Timer1_ISR
001E             69   
001E             70   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             71   org 0x0023 
0023 32          72            reti
0024             73            
0024             74   ; Timer/Counter 2 overflow interrupt vector
005B             75   org 0x005B
005B 020927      76            ljmp CCU_ISR
005E             77   
005E             78   ; These register definitions needed by 'math32.inc'
0030             79   DSEG at 0x30
0030             80   w:        ds 3
0033             81   x:   ds 4
0037             82   y:   ds 4
003B             83   bcd: ds 5
0040             84   buffer: ds 30
005E             85   
005E             86   ; THERMOCOUPLE
005E             87   LM_Result: ds 2
0060             88   TC_Result: ds 2
0062             89   Result: ds 2
0064             90   LM_TEMP: ds 2
0066             91   ; TEMPERATURE
0066             92   SaveT: ds 4
006A             93   goalTemp: ds 2
006C             94   SoakTemp: ds 3           ; set soak temperature
006F             95   ReflTemp: ds 3           ; set refl temperature
0072             96   Display_Power: ds 2
0074             97   ; TIMER COUNTERS         ; contains counters and timers
0074             98   Count5ms: ds 1
0075             99   Count1ms: ds 2           ; Used to determine when (1) second has passed
0077            100   BCD_counterSec: ds 1
0078            101   BCD_counterMin: ds 1
0079            102   BCD_runtimeSec: ds 1
007A            103   BCD_runtimeMin: ds 1
007B            104   ; ALARMS
007B            105   SoakMinAlarm: ds 1               ;contains set time values
007C            106   SoakSecAlarm: ds 1
007D            107   ReflMinAlarm: ds 1
007E            108   ReflSecAlarm: ds 1
007F            109   
007F            110   
0000            111   BSEG
0000            112   mf: dbit 1
0001            113   half_seconds_flag: dbit 1        ; Set to 1 in the ISR every time 1000 ms had passed (actually 1 second flag)
0002            114   seconds_flag: dbit 1
0003            115   timer_done: dbit 1               ; Set to 1 once ready to start countdown
0004            116   refltimer_done: dbit 1           ; Set to 1 once refl timer starts
0005            117   tempdisplay_flag: dbit 1         ; Set to 1 for temp and run time display
0006            118   powerout_flag: dbit 1
0007            119   
005E            120   CSEG
005E            121   ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            122   LCD_RS equ P0.5
005E            123   LCD_RW equ P0.6
005E            124   LCD_E  equ P0.7
005E            125   LCD_D4 equ P1.2
005E            126   LCD_D5 equ P1.3
005E            127   LCD_D6 equ P1.4
005E            128   LCD_D7 equ P1.6
005E            129   
005E            130   ; LCD and Putty Strings
005E 48656C6C   131   _Hello_World: DB 'Hello World!', '\r', '\n',0
     6F20576F
     726C6421
     0D0A00
006D 0D0A00     132   _New_Line: DB '\r\n', 0
0070 536F616B   133   _Soak: DB 'Soak:',0
     3A00
0076 5265666C   134   _Refl: DB 'Refl:',0
     3A00
007C 54656D70   135   _Temperature_LCD: DB 'Temp:',0
     3A00
0082 506F7765   136   _Power: DB 'Power:%',0   
     723A2500
008A 30303043   137   _C:      DB '000C',0
     00
008F 2000       138   _blank: DB ' ',0
0091 30303A30   139   _default: DB '00:00',0
     3000
0097 20202020   140   _clearLCD: DB '                ',0
     20202020
     20202020
     20202020
     00
00A8            141   
                546   $LIST
                117   $LIST
                149   $LIST
1034            151   
1034            152   EX1_ISR:
1034 C2EC       153      clr ECCU
1036 32         154      reti
1037            155      
1037            156   ;---------------------------------;
1037            157   ; Routine to initialize the ISR   ;
1037            158   ; for timer 1                     ;
1037            159   ;---------------------------------;
1037            160   Timer1_Init:
1037 E589       161            mov a, TMOD
1039 540F       162            anl a, #0x0f ; Clear the bits for timer 1
103B 4410       163            orl a, #0x10 ; Configure timer 1 as 16-timer
103D F589       164            mov TMOD, a
103F 758D6F     165            mov TH1, #high(TIMER1_RELOAD)
1042 758BFF     166            mov TL1, #low(TIMER1_RELOAD)
1045            167            ; Enable the timer and interrupts
1045 D2AB       168       setb ET1  ; Enable timer 1 interrupt
1047 D28E       169       setb TR1  ; Start timer 1
1049 22         170            ret
104A            171   
104A            172   ;---------------------------------;
104A            173   ; ISR for timer 1                 ;
104A            174   ;---------------------------------;
104A            175   Timer1_ISR:
104A 758D6F     176            mov TH1, #high(TIMER1_RELOAD)
104D 758BFF     177            mov TL1, #low(TIMER1_RELOAD)
1050            178            
1050            179            ; The two registers used in the ISR must be saved in the stack
1050 C0E0       180            push acc
1052 C0D0       181            push psw
1054            182            
1054            183            ; Increment the 8-bit 5-mili-second counter
1054 0574       184            inc Count5ms
1056            185   
1056            186   Inc_Done:
1056            187            ; Check if half second has passed
1056 E574       188            mov a, Count5ms
1058 B4C821     189            cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
105B            190            
105B            191            ; 1000 milliseconds have passed.  Set a flag so the main program knows
105B D202       192            setb seconds_flag ; Let the main program know half second had passed
105D            193            ; Reset to zero the 5-milli-seconds counter, it is a 8-bit variable
105D 757400     194            mov Count5ms, #0
1060            195            
1060            196            ; decrement seconds
1060 E577       197            mov a , BCD_counterSec
1062 2499       198            add a, #0x99
1064 D4         199            da a
1065 F577       200            mov BCD_counterSec, a
1067 B49912     201            cjne a, #0x99, Timer1_ISR_done
106A 757759     202            mov BCD_counterSec, #0x59
106D            203            ;decrement minutes
106D E578       204            mov a , BCD_counterMin
106F 2499       205            add a, #0x99
1071 D4         206            da a
1072 F578       207            mov BCD_counterMin, a
1074 B49905     208            cjne a, #0x99, Timer1_ISR_done  ;If timer minutes at 0, set timerdone flag
1077 D203       209            setb timer_done         
1079 757800     210            mov BCD_counterMin, #0x00
107C            211            
107C            212   Timer1_ISR_done:
107C D0D0       213            pop psw
107E D0E0       214            pop acc
1080 32         215            reti
1081            216            
1081            217   ;----------------------;
1081            218   ;    MAIN PROGRAM      ;
1081            219   ;----------------------;
1081            220   MainProgram:
1081 75817F     221       mov SP, #0x7F
1084            222       
1084            223       
1084 120CD4     224       lcall InitSerialPort
1087 120CAB     225       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
108A 12010D     226       lcall LCD_4BIT
108D 120D1D     227       lcall Double_Clk
1090 120CFA     228            lcall InitADC0 ; Call after 'Ports_Init'
1093 120910     229            lcall CCU_Init  ; voice feedback interrupt
1096 121037     230            lcall Timer1_Init
1099            231            
1099            232            ; set/clear interrupts
1099 D2A7       233            setb POWER
109B C28E       234            clr TR1
109D C2C8       235            clr TMOD20 ; Stop CCU timer
109F C280       236            clr SOUND ; Turn speaker off
10A1 C207       237            clr T2S_FSM_Start
10A3 D2AF       238            setb EA ; Enable global interrupts.
10A5            239   
10A5            240   
10A5            241            
10A5 753100     242            mov seconds, #0x00
10A8 753000     243            mov minutes, #0x00
10AB 756C00     244       mov SoakTemp, #0x00
10AE 756F00     245            mov ReflTemp, #0x00
10B1 756A00     246            mov GoalTemp, #0x00
10B4 756D00     247            mov SoakTemp+1, #0x00
10B7 757000     248            mov ReflTemp+1, #0x00
10BA 756C00     249       mov SoakTemp, #0x00
10BD 756F00     250            mov ReflTemp, #0x00
10C0 757700     251            mov BCD_counterSec, #0x00
10C3 757800     252            mov BCD_counterMin, #0x00 
10C6 757B00     253            mov SoakMinAlarm, #0x00
10C9 757C00     254            mov SoakSecAlarm, #0x00
10CC 757D00     255            mov ReflMinAlarm, #0x00
10CF 757E00     256            mov ReflSecAlarm, #0x00
10D2            257   
10D2            258   
10D2            259            ; initialize vars
10D2            260            ;mov T2S_FSM_state, #0
10D2            261   
10D2            262            
10D2            263       ;set constant strings lcd
10D2 C0E0       264            push acc
10D4 7401       264            mov a, #1
10D6 14         264            dec a
10D7 12014F     264            lcall ?Set_Cursor_1 ; Select column and row
10DA D0E0       264            pop acc
10DC C083       265            push dph
10DE C082       265            push dpl
10E0 C0E0       265            push acc
10E2 900070     265            mov dptr, #_Soak
10E5 120142     265            lcall ?Send_Constant_String
10E8 D0E0       265            pop acc
10EA D082       265            pop dpl
10EC D083       265            pop dph
10EE C0E0       266            push acc
10F0 7406       266            mov a, #6
10F2 14         266            dec a
10F3 12014F     266            lcall ?Set_Cursor_1 ; Select column and row
10F6 D0E0       266            pop acc
10F8 C083       267            push dph
10FA C082       267            push dpl
10FC C0E0       267            push acc
10FE 90008A     267            mov dptr, #_C
1101 120142     267            lcall ?Send_Constant_String
1104 D0E0       267            pop acc
1106 D082       267            pop dpl
1108 D083       267            pop dph
110A C0E0       268            push acc
110C 740A       268            mov a, #10
110E 14         268            dec a
110F 12014F     268            lcall ?Set_Cursor_1 ; Select column and row
1112 D0E0       268            pop acc
1114 C083       269            push dph
1116 C082       269            push dpl
1118 C0E0       269            push acc
111A 90008F     269            mov dptr, #_blank
111D 120142     269            lcall ?Send_Constant_String
1120 D0E0       269            pop acc
1122 D082       269            pop dpl
1124 D083       269            pop dph
1126 C0E0       270            push acc
1128 740B       270            mov a, #11
112A 14         270            dec a
112B 12014F     270            lcall ?Set_Cursor_1 ; Select column and row
112E D0E0       270            pop acc
1130 C083       271            push dph
1132 C082       271            push dpl
1134 C0E0       271            push acc
1136 900091     271            mov dptr, #_default
1139 120142     271            lcall ?Send_Constant_String
113C D0E0       271            pop acc
113E D082       271            pop dpl
1140 D083       271            pop dph
1142            272             
1142 C0E0       273            push acc
1144 7401       273            mov a, #1
1146 14         273            dec a
1147 12014D     273            lcall ?Set_Cursor_2 ; Select column and row
114A D0E0       273            pop acc
114C C083       274            push dph
114E C082       274            push dpl
1150 C0E0       274            push acc
1152 900076     274            mov dptr, #_Refl
1155 120142     274            lcall ?Send_Constant_String
1158 D0E0       274            pop acc
115A D082       274            pop dpl
115C D083       274            pop dph
115E C0E0       275            push acc
1160 7406       275            mov a, #6
1162 14         275            dec a
1163 12014D     275            lcall ?Set_Cursor_2 ; Select column and row
1166 D0E0       275            pop acc
1168 C083       276            push dph
116A C082       276            push dpl
116C C0E0       276            push acc
116E 90008A     276            mov dptr, #_C
1171 120142     276            lcall ?Send_Constant_String
1174 D0E0       276            pop acc
1176 D082       276            pop dpl
1178 D083       276            pop dph
117A C0E0       277            push acc
117C 740A       277            mov a, #10
117E 14         277            dec a
117F 12014D     277            lcall ?Set_Cursor_2 ; Select column and row
1182 D0E0       277            pop acc
1184 C083       278            push dph
1186 C082       278            push dpl
1188 C0E0       278            push acc
118A 90008F     278            mov dptr, #_blank
118D 120142     278            lcall ?Send_Constant_String
1190 D0E0       278            pop acc
1192 D082       278            pop dpl
1194 D083       278            pop dph
1196 C0E0       279            push acc
1198 740B       279            mov a, #11
119A 14         279            dec a
119B 12014D     279            lcall ?Set_Cursor_2 ; Select column and row
119E D0E0       279            pop acc
11A0 C083       280            push dph
11A2 C082       280            push dpl
11A4 C0E0       280            push acc
11A6 900091     280            mov dptr, #_default
11A9 120142     280            lcall ?Send_Constant_String
11AC D0E0       280            pop acc
11AE D082       280            pop dpl
11B0 D083       280            pop dph
11B2            281   
11B2            282   
11B2            283            
11B2 0211B5     284            ljmp State0_SetupSoak                   ; sets up all soak temp, time, refl temp, time before counter start
11B5            285   
11B5            286   ;-------------------------------------;
11B5            287   ;        STATE0 SET SOAK/REFL SETTINGS     ;
11B5            288   ;-------------------------------------;
11B5            289   ;--------- SETUP SOAK ---------;
11B5            290   State0_SetupSoak:
11B5            291   
11B5 20A631     292            jb BOOT_BUTTON, SetSoakTemp  ; if the 'BOOT' button is not pressed skip
11B8 C002       293            push AR2
11BA 7A32       293            mov R2, #50
11BC 1200B1     293            lcall ?Wait_Milli_Seconds
11BF D002       293            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
11C1 20A625     294            jb BOOT_BUTTON, SetSoakTemp  ; if the 'BOOT' button is not pressed skip
11C4 30A6FD     295            jnb BOOT_BUTTON, $
11C7            296            
11C7            297            ;Make LCD screen blink??
11C7            298   
11C7 E4         299            clr a                                   ; clear all settings
11C8 F56C       300            mov SoakTemp, a
11CA F57B       301            mov SoakMinAlarm, a
11CC F57C       302            mov SoakSecAlarm, a
11CE 12016A     303            lcall Display_Soak      
11D1            304                    
11D1 0211B5     305            ljmp State0_SetupSoak   ;loops in Setup until Start button pressed
11D4            306   
11D4            307   CheckReflSet:                    ; if startmode button pressed, set refl
11D4 20B0DE     308            jb STARTSTOP_BUTTON, State0_SetupSoak
11D7 C002       309            push AR2
11D9 7A32       309            mov R2, #50
11DB 1200B1     309            lcall ?Wait_Milli_Seconds
11DE D002       309            pop AR2
11E0 20B0D2     310       jb STARTSTOP_BUTTON, State0_SetupSoak
11E3 30B0FD     311       jnb STARTSTOP_BUTTON, $
11E6 021273     312       ljmp State0_SetupRefl
11E9            313            
11E9            314   SetSoakTemp:
11E9 208229     315            jb TEMP_BUTTON, SetSoakMin ; if 'soak min' button is not pressed, check soak sec
11EC C002       316            push AR2
11EE 7A32       316            mov R2, #50
11F0 1200B1     316            lcall ?Wait_Milli_Seconds
11F3 D002       316            pop AR2
11F5 20821D     317       jb TEMP_BUTTON, SetSoakMin
11F8 3082FD     318       jnb TEMP_BUTTON, $
11FB            319       
11FB            320       ; increment Soak temp
11FB E56C       321            mov a, SoakTemp
11FD B49007     322            cjne a, #0x90, dontincrementhigherSOAK
1200            323   incrementhigherSOAK:
1200 E56D       324            mov a, SoakTemp+1
1202 2401       325            add a, #0x01
1204 D4         326            da a
1205 F56D       327            mov SoakTemp+1, a
1207            328   dontincrementhigherSOAK:
1207 E56C       329            mov a, SoakTemp
1209 2410       330            add a, #0x10
120B D4         331            da a
120C F56C       332            mov SoakTemp, a
120E E4         333            clr a
120F 12016A     334            lcall Display_Soak
1212 0211B5     335            ljmp State0_SetupSoak
1215            336            
1215            337   SetSoakMin:
1215 20832C     338            jb ALMIN_BUTTON, SetSoakSec
1218 C002       339            push AR2
121A 7A32       339            mov R2, #50
121C 1200B1     339            lcall ?Wait_Milli_Seconds
121F D002       339            pop AR2
1221 208320     340       jb ALMIN_BUTTON, SetSoakSec
1224 3083FD     341       jnb ALMIN_BUTTON, $
1227            342       
1227            343            ; Now increment Soak min
1227 E57B       344            mov a, SoakMinAlarm
1229 B4590C     345            cjne a, #0x59, incrementSM              ;if not equal to 59, add 1
122C 7400       346            mov a, #0x00
122E D4         347            da a
122F F57B       348            mov SoakMinAlarm, a
1231 E4         349            clr a
1232 12016A     350            lcall Display_Soak
1235 0211B5     351            ljmp State0_SetupSoak   
1238            352   incrementSM:
1238 2401       353            add a, #0x01
123A D4         354            da a
123B F57B       355            mov SoakMinAlarm, a
123D E4         356            clr a
123E 12016A     357            lcall Display_Soak
1241 0211B5     358            ljmp State0_SetupSoak
1244            359            
1244            360   SetSoakSec:
1244 20818D     361            jb ALSEC_BUTTON, CheckReflSet
1247 C002       362            push AR2
1249 7A32       362            mov R2, #50
124B 1200B1     362            lcall ?Wait_Milli_Seconds
124E D002       362            pop AR2
1250 208181     363       jb ALSEC_BUTTON, CheckReflSet
1253 3081FD     364       jnb ALSEC_BUTTON, $
1256            365       
1256            366            ; Now increment Soak sec
1256 E57C       367            mov a, SoakSecAlarm
1258 B4590C     368            cjne a, #0x59, incrementSS              ;if not equal to 59, add 1
125B 7400       369            mov a, #0x00
125D D4         370            da a
125E F57C       371            mov SoakSecAlarm, a
1260 E4         372            clr a
1261 12016A     373            lcall Display_Soak
1264 0211B5     374            ljmp State0_SetupSoak
1267            375   incrementSS:
1267 2401       376            add a, #0x01
1269 D4         377            da a
126A F57C       378            mov SoakSecAlarm, a
126C E4         379            clr a
126D 12016A     380            lcall Display_Soak
1270 0211B5     381            ljmp State0_SetupSoak
1273            382       
1273            383   ;--------- SETUP REFLOW  --------;
1273            384   State0_SetupRefl:
1273 20A61C     385            jb BOOT_BUTTON, SetReflTemp  ; if the 'BOOT' button is not pressed skip
1276 C002       386            push AR2
1278 7A32       386            mov R2, #50
127A 1200B1     386            lcall ?Wait_Milli_Seconds
127D D002       386            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
127F 20A610     387            jb BOOT_BUTTON, SetReflTemp  ; if the 'BOOT' button is not pressed skip
1282 30A6FD     388            jnb BOOT_BUTTON, $
1285            389            
1285            390            ;Make LCD screen blink??
1285            391            
1285 E4         392            clr a
1286 F56F       393            mov ReflTemp, a
1288 F57D       394            mov ReflMinAlarm, a
128A F57E       395            mov ReflSecAlarm, a
128C 1201D3     396            lcall Display_Refl      
128F            397            
128F 021273     398            ljmp State0_SetupRefl   ;loops in Setup until Start button pressed
1292            399            
1292            400   SetReflTemp:
1292 208229     401            jb TEMP_BUTTON, SetReflMin ; if 'soak min' button is not pressed, check soak sec
1295 C002       402            push AR2
1297 7A32       402            mov R2, #50
1299 1200B1     402            lcall ?Wait_Milli_Seconds
129C D002       402            pop AR2
129E 20821D     403       jb TEMP_BUTTON, SetReflMin
12A1 3082FD     404       jnb TEMP_BUTTON, $
12A4            405       ; increment Soak temp
12A4 E56F       406            mov a, ReflTemp
12A6 B49007     407            cjne a, #0x90, dontincrementhigherREFL
12A9            408   incrementhigherREFL:
12A9 E570       409            mov a, ReflTemp+1
12AB 2401       410            add a, #0x01
12AD D4         411            da a
12AE F570       412            mov ReflTemp+1, a
12B0            413   dontincrementhigherREFL:
12B0 E56F       414            mov a, ReflTemp
12B2 2410       415            add a, #0x10
12B4 D4         416            da a
12B5 F56F       417            mov ReflTemp, a
12B7 E4         418            clr a
12B8 1201D3     419            lcall Display_Refl
12BB 021273     420            ljmp State0_SetupRefl
12BE            421            
12BE            422   SetReflMin:
12BE 20834E     423            jb ALMIN_BUTTON, SetReflSec
12C1 C002       424            push AR2
12C3 7A32       424            mov R2, #50
12C5 1200B1     424            lcall ?Wait_Milli_Seconds
12C8 D002       424            pop AR2
12CA 208342     425       jb ALMIN_BUTTON, SetReflSec
12CD 3083FD     426       jnb ALMIN_BUTTON, $
12D0            427       
12D0            428            ; Now increment Soak min
12D0 E57D       429            mov a, ReflMinAlarm
12D2 B4590C     430            cjne a, #0x59, incrementRM              ;if not equal to 59, add 1
12D5 7400       431            mov a, #0x00
12D7 D4         432            da a
12D8 F57D       433            mov ReflMinAlarm, a
12DA E4         434            clr a
12DB 1201D3     435            lcall Display_Refl
12DE 021273     436            ljmp State0_SetupRefl
12E1            437   incrementRM:
12E1 2401       438            add a, #0x01
12E3 D4         439            da a
12E4 F57D       440            mov ReflMinAlarm, a
12E6 E4         441            clr a
12E7 1201D3     442            lcall Display_Refl
12EA 021273     443            ljmp State0_SetupRefl
12ED            444   
12ED            445   
12ED            446   CheckStartTimer:                 ; if modestart buttup pressed, start timer and main loop
12ED            447            
12ED 20B01C     448            jb STARTSTOP_BUTTON, jumpercst
12F0 C002       449            push AR2
12F2 7A32       449            mov R2, #50
12F4 1200B1     449            lcall ?Wait_Milli_Seconds
12F7 D002       449            pop AR2
12F9 20B010     450       jb STARTSTOP_BUTTON, jumpercst
12FC 30B0FD     451       jnb STARTSTOP_BUTTON, $
12FF            452   
12FF            453            ;------------------------- TODO ----------------------------;
12FF            454            ; Voice Feedback Soak stage
12FF            455            ;-----------------------------------------------------------;   
12FF            456            
12FF            457            ; temp stuff, clear bits
12FF E4         458            clr a
1300 F534       459            mov x+1,a
1302 F535       460            mov x+2,a
1304 F536       461            mov x+3,a
1306            462   
1306            463            ;------------------------- TODO ----------------------------;
1306            464            ; Change display to ramp soak?
1306            465            ;-----------------------------------------------------------;
1306 856C6A     466            mov goalTemp, SoakTemp          ;track current vs goalTemp
1309            467            
1309 02133E     468            ljmp State1_RampSoak
130C            469   jumpercst:
130C 021273     470            ljmp State0_SetupRefl
130F            471   
130F            472   SetReflSec:
130F 2081DB     473            jb ALSEC_BUTTON, CheckStartTimer
1312 C002       474            push AR2
1314 7A32       474            mov R2, #50
1316 1200B1     474            lcall ?Wait_Milli_Seconds
1319 D002       474            pop AR2
131B 2081CF     475       jb ALSEC_BUTTON, CheckStartTimer
131E 3081FD     476       jnb ALSEC_BUTTON, $
1321            477       
1321            478            ; Now increment Soak sec
1321 E57E       479            mov a, ReflSecAlarm
1323 B4590C     480            cjne a, #0x59, incrementRS              ;if not equal to 59, add 1
1326 7400       481            mov a, #0x00
1328 D4         482            da a
1329 F57E       483            mov ReflSecAlarm, a
132B E4         484            clr a
132C 1201D3     485            lcall Display_Refl
132F 021273     486            ljmp State0_SetupRefl
1332            487   incrementRS:
1332 2401       488            add a, #0x01
1334 D4         489            da a
1335 F57E       490            mov ReflSecAlarm, a
1337 E4         491            clr a
1338 1201D3     492            lcall Display_Refl
133B 021273     493            ljmp State0_SetupRefl
133E            494      
133E            495   ;--------------------------------;
133E            496   ;                STATE1 RAMP SOAK             ;
133E            497   ;--------------------------------; 
133E            498   State1_RampSoak:
133E            499    ; 100% power
133E            500   
133E 120BCB     501            lcall ReadTemp
1341 C2A7       502            clr POWER
1343            503            
1343 20B115     504            jb MODE_BUTTON, SwitchDisplay_S1                ; if stop button not pressed, go loop and check for 00
1346 C002       505            push AR2
1348 7A32       505            mov R2, #50
134A 1200B1     505            lcall ?Wait_Milli_Seconds
134D D002       505            pop AR2
134F 20B109     506       jb MODE_BUTTON, SwitchDisplay_S1
1352 30B1FD     507       jnb MODE_BUTTON, $
1355            508       
1355 20053E     509            jb tempdisplay_flag, TimerDisplayJmp2
1358 300538     510            jnb tempdisplay_flag, TempDisplayJmp2
135B            511            
135B            512   SwitchDisplay_S1:
135B 120BCB     513            lcall ReadTemp
135E 757264     514            mov Display_Power, #1100100B    ;power at 100%
1361            515   
1361            516   ; Compare upper byte
1361            517   CompareUpperB_S1:
1361 856C3B     518            mov bcd+0,SoakTemp+0
1364 856D3C     519            mov bcd+1,SoakTemp+1
1367 753D00     520            mov bcd+2,#0
136A 753E00     521            mov bcd+3,#0
136D 753F00     522            mov bcd+4,#0
1370            523            
1370 120729     524            lcall bcd2hex
1373            525   
1373 E534       526            mov a, x+1 ;SoakTemp+1
1375 C3         527            clr c
1376 9563       528            subb a,Result+1         ;Soak-Temp
1378 5003       529            jnc CompareLowerB_S1            ; if SoakTemp>Result UB, check LB, else end state
137A 021384     530            ljmp End_S1
137D            531   CompareLowerB_S1:
137D            532   
137D E533       533            mov a, x+0 ;SoakTemp+0
137F            534            
137F C3         535            clr c
1380 9562       536            subb a,Result+0
1382 50BA       537            jnc State1_RampSoak ; if SoakTemp<Result LB, loop, else end state
1384            538   ; If Soak Temp reached, proceed
1384            539   End_S1:
1384 857B78     540            mov BCD_counterMin, SoakMinAlarm        ; move time settings into counters
1387 857C77     541            mov BCD_counterSec, SoakSecAlarm
138A C203       542            clr timer_done
138C C204       543            clr refltimer_done; clear timer done flags
138E D28E       544            setb TR1                        ;Start Timer
1390 021399     545            ljmp Forever
1393            546            ;------------------------- TODO -------------------------------;
1393            547            ; Implement safety feature (if Temp < 50C in first 60s, abort) ;
1393            548            ;--------------------------------------------------------------;
1393            549   
1393            550   ;----------------------;
1393            551   ;       JMP FUNCS      ;
1393            552   ;----------------------;
1393            553   TempDisplayJmp2:
1393 02049A     554            ljmp TempDisplay2
1396            555   TimerDisplayJmp2:
1396 02057D     556            ljmp TimerDisplay2
1399            557            
1399            558   ;------------------------------------;
1399            559   ;                 STATE2&4 MAIN LOOP              ;
1399            560   ;------------------------------------;
1399            561   
1399            562   ; forever loop interface with putty
1399            563   Forever:
1399            564             ; 20% pwm for soak and refl
1399            565   
1399            566            ; check temperature
1399 120BCB     567            lcall ReadTemp
139C            568            
139C 856C3B     569            mov bcd+0,SoakTemp+0
139F 856D3C     570            mov bcd+1,SoakTemp+1
13A2 753D00     571            mov bcd+2,#0
13A5 753E00     572            mov bcd+3,#0
13A8 753F00     573            mov bcd+4,#0
13AB            574            
13AB 120729     575            lcall bcd2hex
13AE E534       576            mov a, x+1 ;SoakTemp+1
13B0 C3         577            clr c
13B1            578            
13B1 9563       579            subb a,Result+1         ;Soak-Temp
13B3 5003       580            jnc CompareLowerSTATE2          
13B5 0213C3     581            ljmp POWER_STATE2;if soak<current temp, enable power
13B8            582   
13B8            583            
13B8            584   CompareLowerSTATE2:
13B8 E533       585            mov a, x+0 ;SoakTemp+0
13BA            586            
13BA C3         587            clr c
13BB 9562       588            subb a,Result+0
13BD 5004       589            jnc POWER_STATE2;if soak<current temp, enable power
13BF            590   
13BF            591            ;0% POWER
13BF D2A7       592       setb POWER ; led off
13C1 8016       593       sjmp STATE2POWERSKIP
13C3            594       
13C3            595   POWER_STATE2:
13C3            596            ;20% POWER
13C3 C2A7       597            clr POWER ; Led on
13C5 C002       598            push AR2
13C7 7A14       598            mov R2, #20
13C9 1200B1     598            lcall ?Wait_Milli_Seconds
13CC D002       598            pop AR2
13CE D2A7       599       setb POWER ; led off
13D0 C002       600            push AR2
13D2 7A50       600            mov R2, #80
13D4 1200B1     600            lcall ?Wait_Milli_Seconds
13D7 D002       600            pop AR2
13D9            601   STATE2POWERSKIP:    
13D9            602       
13D9            603   
13D9            604            ; Voice Feedback
13D9            605            ;lcall T2S_FSM          ; Run the state machine that plays minutes:seconds
13D9            606   
13D9 757220     607            mov Display_Power, #0x20        ;power at 20% for Soak and Refl Stages 2&4
13DC            608            
13DC 30020D     609            jnb seconds_flag, CheckButtons
13DF            610            ; One second has passed, refresh the LCD with new time
13DF            611            
13DF 200337     612            jb timer_done, TimerDoneJmp             ;check if timer done
13E2 C202       613            clr seconds_flag
13E4 200529     614            jb tempdisplay_flag, TempDisplayJmp     ; if temp mode button pressed, show temp display
13E7            615            
13E7 02028E     616            ljmp WriteNum 
13EA            617   
13EA            618            ; Do this forever
13EA 8000       619            sjmp CheckButtons
13EC            620   
13EC            621   CheckButtons:
13EC            622            ; TIME CHECK
13EC 20A62D     623            jb BOOT_BUTTON, CheckStop  ; buttons to change screen to Clock and Current Temp later
13EF C002       624            push AR2
13F1 7A32       624            mov R2, #50
13F3 1200B1     624            lcall ?Wait_Milli_Seconds
13F6 D002       624            pop AR2
13F8 20A621     625            jb BOOT_BUTTON, CheckStop
13FB 30A6FD     626            jnb BOOT_BUTTON, $
13FE            627            
13FE C28E       628            clr TR1                 ; Stop timer 2
1400 E4         629            clr a
1401 757700     630            mov BCD_counterSec, #0x00
1404 757800     631            mov BCD_counterMin, #0x00
1407 12016A     632            lcall Display_Soak
140A 1201D3     633            lcall Display_Refl
140D            634            
140D 0211B5     635            ljmp State0_SetupSoak
1410            636   
1410            637   
1410            638   ;----------------------;
1410            639   ;       JMP FUNCS      ;
1410            640   ;----------------------;
1410            641   TempDisplayJmp:
1410 020294     642            ljmp TempDisplay
1413            643   TimerDisplayJmp:
1413 020377     644            ljmp TimerDisplay
1416            645   ForeverJmp:
1416 021399     646            ljmp Forever
1419            647   TimerDoneJmp:
1419 02146A     648            ljmp TimerDone
141C            649            
141C            650   ; add another button for display that will loop to loop_a after
141C            651   CheckStop:
141C 20B031     652       jb STARTSTOP_BUTTON, VoiceFeedback           ; if stop button not pressed, go loop and display
141F C002       653            push AR2
1421 7A32       653            mov R2, #50
1423 1200B1     653            lcall ?Wait_Milli_Seconds
1426 D002       653            pop AR2
1428 20B025     654       jb STARTSTOP_BUTTON, VoiceFeedback
142B 30B0FD     655       jnb STARTSTOP_BUTTON, $
142E C28E       656       clr TR1                 ; Stop timer 2
1430 C2A7       657       clr POWER                            ; stop power
1432            658            ;------------------------- TODO ----------------------------;
1432            659            ; Turn off power oven
1432            660            ;-----------------------------------------------------------;   
1432 0211B5     661            ljmp State0_SetupSoak           ; if stop button pressed, go back to setup
1435            662                    
1435            663   SwitchDisplays:
1435 20B1DE     664            jb MODE_BUTTON, ForeverJmp              ; if stop button not pressed, go loop and check for 00
1438 C002       665            push AR2
143A 7A32       665            mov R2, #50
143C 1200B1     665            lcall ?Wait_Milli_Seconds
143F D002       665            pop AR2
1441 20B1D2     666       jb MODE_BUTTON, ForeverJmp
1444 30B1FD     667       jnb MODE_BUTTON, $
1447            668            
1447 2005C9     669            jb tempdisplay_flag, TimerDisplayJmp
144A 3005C3     670            jnb tempdisplay_flag, TempDisplayJmp
144D 021399     671            ljmp Forever
1450            672   
1450            673   VoiceFeedback:   
1450            674            ; Voice Feedback
1450 2082E2     675            jb TEMP_BUTTON, SwitchDisplays          ; if stop button not pressed, go loop and display
1453 C002       676            push AR2
1455 7A32       676            mov R2, #50
1457 1200B1     676            lcall ?Wait_Milli_Seconds
145A D002       676            pop AR2
145C 2082D6     677       jb TEMP_BUTTON, SwitchDisplays
145F            678   
145F 857731     679       mov seconds, BCD_counterSec
1462 857830     680       mov minutes, BCD_counterMin
1465 D207       681            setb T2S_FSM_Start      ; This plays the current minutes:seconds by making the state machine get out of state zero.
1467 021399     682            ljmp Forever
146A            683   
146A            684   TimerDone:               ; if timer done
146A C28E       685            clr TR1                 ; Stop timer 2
146C E4         686            clr a
146D 856F6A     687            mov goalTemp, ReflTemp          ;track current vs goalTemp
1470 300406     688            jnb refltimer_done, State3_RampRefl             ; if reflow timer not done, start reflow timer
1473            689            ;else if refltimer done, finish process
1473 756A00     690            mov goalTemp, #0x00             ;track current vs goalTemp
1476 0214DE     691            ljmp State5_Cool                ; go to Cool state
1479            692   
1479            693            
1479            694   ;--------------------------------;
1479            695   ;                STATE3 RAMP REFL             ;
1479            696   ;--------------------------------;
1479            697   State3_RampRefl:
1479            698            ; 100% power
1479            699            
1479 120BCB     700            lcall ReadTemp
147C C2A7       701            clr POWER
147E            702            
147E 20B115     703            jb MODE_BUTTON, SwitchDisplay_S3                ; if stop button not pressed, go loop and check for 00
1481 C002       704            push AR2
1483 7A32       704            mov R2, #50
1485 1200B1     704            lcall ?Wait_Milli_Seconds
1488 D002       704            pop AR2
148A 20B109     705       jb MODE_BUTTON, SwitchDisplay_S3
148D 30B1FD     706       jnb MODE_BUTTON, $
1490            707       
1490 200532     708            jb tempdisplay_flag, TimerDisplayJmp3
1493 30052C     709            jnb tempdisplay_flag, TempDisplayJmp3
1496            710            
1496            711   SwitchDisplay_S3:
1496 120BCB     712            lcall ReadTemp
1499 757264     713            mov Display_Power, #1100100B    ;power at 100%
149C            714   
149C            715   ; Compare upper byte
149C 856F3B     716            mov bcd+0,ReflTemp+0
149F 85703C     717            mov bcd+1,ReflTemp+1
14A2 753D00     718            mov bcd+2,#0
14A5 753E00     719            mov bcd+3,#0
14A8 753F00     720            mov bcd+4,#0
14AB            721            
14AB 120729     722            lcall bcd2hex
14AE            723   
14AE            724   
14AE            725   CompareUpperB_S3:
14AE E534       726            mov a, x+1
14B0 C3         727            clr c
14B1 9563       728            subb a, Result+1        ;Soak-Temp
14B3 5003       729            jnc CompareLowerB_S3            ; if SoakTemp>Result UB, check LB, else end state
14B5 0214C8     730            ljmp End_S3
14B8            731   CompareLowerB_S3:
14B8 E533       732            mov a, x+0
14BA C3         733            clr c
14BB 9562       734            subb a, Result+0
14BD 50BA       735            jnc State3_RampRefl ; if SoakTemp<Result LB, loop, else end state
14BF            736   ; If Soak Temp reached, proceed
14BF 0214C8     737            ljmp End_S3
14C2            738   ;----------------------;
14C2            739   ;       JMP FUNCS      ;
14C2            740   ;----------------------;
14C2            741   TempDisplayJmp3:
14C2 020294     742            ljmp TempDisplay
14C5            743   TimerDisplayJmp3:
14C5 020377     744            ljmp TimerDisplay
14C8            745   
14C8            746   ;---------------------------;
14C8            747   ;                STATE4 REFL         ;
14C8            748   ;---------------------------; 
14C8            749   End_S3:
14C8 C203       750            clr timer_done
14CA D204       751            setb refltimer_done             ; set to indicate final stage in process
14CC 857D78     752            mov BCD_counterMin, ReflMinAlarm        ; move time settings into counters
14CF 857E77     753            mov BCD_counterSec, ReflSecAlarm
14D2 C203       754            clr timer_done
14D4 D204       755            setb refltimer_done; clear timer done flags
14D6 D28E       756            setb TR1                        ;Start Timer
14D8 856F6A     757            mov goalTemp, ReflTemp
14DB 021399     758            ljmp Forever
14DE            759            
14DE            760   ;---------------------------;
14DE            761   ;                STATE5 COOLING              ;
14DE            762   ;---------------------------; 
14DE            763   State5_Cool:
14DE            764   ;        pwn 0%
14DE            765   
14DE 120BCB     766            lcall ReadTemp
14E1 D2A7       767            setb POWER              ;power off
14E3            768            
14E3 20B115     769            jb MODE_BUTTON, SwitchDisplay_S5                ; if stop button not pressed, go loop and check for 00
14E6 C002       770            push AR2
14E8 7A32       770            mov R2, #50
14EA 1200B1     770            lcall ?Wait_Milli_Seconds
14ED D002       770            pop AR2
14EF 20B109     771       jb MODE_BUTTON, SwitchDisplay_S5
14F2 30B1FD     772       jnb MODE_BUTTON, $
14F5            773       
14F5 2005CD     774            jb tempdisplay_flag, TimerDisplayJmp3
14F8 3005C7     775            jnb tempdisplay_flag, TempDisplayJmp3
14FB            776            
14FB            777   SwitchDisplay_S5:
14FB 120BCB     778            lcall ReadTemp
14FE 757200     779            mov Display_Power, #0x00        ;power at 0%
1501            780   ; Compare upper byte
1501            781   CompareUpperB_S5:
1501 E563       782            mov a, Result+1
1503 C3         783            clr c
1504 9400       784            subb a, #0x00   ;Soak-Temp
1506 5003       785            jnc CompareLowerB_S5            ; if SoakTemp>Result UB, check LB, else end state
1508 021512     786            ljmp End_S5
150B            787   CompareLowerB_S5:
150B E562       788            mov a, Result+0                 ;change to 0x60 later
150D C3         789            clr c
150E 9460       790            subb a, #0x60
1510 50CC       791            jnc State5_Cool ; if SoakTemp<Result LB, loop, else end state
1512            792   ; If Cooling temp reached, proceed
1512            793   ;---------------------------;
1512            794   ;                STATE4 REFL         ;
1512            795   ;---------------------------; 
1512            796   End_S5:
1512 C28E       797            clr TR1
1514 C203       798            clr timer_done
1516 C204       799            clr refltimer_done              ; set to indicate final stage in process
1518            800            ;reset all settings
1518 756C00     801            mov SoakTemp, #0x00
151B 756F00     802            mov ReflTemp, #0x00
151E 757700     803            mov BCD_counterSec, #0x00
1521 757800     804            mov BCD_counterMin, #0x00
1524 757B00     805            mov SoakMinAlarm, #0x00
1527 757C00     806            mov SoakSecAlarm, #0x00
152A 757D00     807            mov ReflMinAlarm, #0x00
152D 757E00     808            mov ReflSecAlarm, #0x00
1530 12016A     809            lcall Display_Soak
1533 1201D3     810            lcall Display_Refl
1536            811            
1536 0211B5     812            ljmp State0_SetupSoak
1539            813            
1539            814   END
